% \iffalse meta-comment
%
% Copyright (C) 2008 by Ulrich M. Schwarz
%
% This file may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3a.
% The license can be obtained from
% http://www.latex-project.org/lppl/lppl-1-3a.txt
%
% \fi
%
%\iffalse (hide this from DocInput)
%<*driver>
\documentclass{ltxdoc}

\usepackage[T1]{fontenc}
\usepackage{fourier}
\usepackage[scaled=0.8]{helvet}
\usepackage{luximono}

\usepackage{amsmath, amsthm}
\usepackage{thm-patch}
\newtheorem{lemma}{Lemma}
\providecommand\pkg{\textsf}
\GetFileInfo{thm-patch.sty}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}

 \newcommand\thmpatch{\textsf{thm-patch}}
 \title{The \thmpatch\ package\thanks{%
   This file documents version~\fileversion\ of~\filedate,
   RCS ${}$Id: thm-patch.dtx,v 1.15 2008/09/02 19:33:09 ulmi Exp ulmi ${}$.
 }}
 \author{Ulrich M. Schwarz\thanks{ulmi@absatzen.de}}

 \maketitle

\begin{abstract}
\end{abstract}

  \DocInput{thm-patch.dtx}
\end{document}
%</driver>
%<*patch>
%\fi
%
% \CharacterTable
% {Upper-case \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
% Lower-case \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
% Digits \0\1\2\3\4\5\6\7\8\9
% Exclamation \! Double quote \" Hash (number) \#
% Dollar \$ Percent \% Ampersand \&
% Acute accent \' Left paren \( Right paren \)
% Asterisk \* Plus \+ Comma \,
% Minus \- Point \. Solidus \/
% Colon \: Semicolon \; Less than \<
% Equals \= Greater than \> Question mark \?
% Commercial at \@ Left bracket \[ Backslash \\
% Right bracket \] Circumflex \^ Underscore \_
% Grave accent \` Left brace \{ Vertical bar \|
% Right brace \} Tilde \~}
% \CheckSum{160}
%
% \DoNotIndex{\@for,\addtocounter,\arabic,\csname,\endcsname,\cup,\CurrentOption}
% \DoNotIndex{\{,\},\do,\define@key,\def,\DeclareOption,\else,\ensuremath,\expandafter}
% \DoNotIndex{\hspace,\fi,\rule,\ifcase,\ifx,\in,\InputIfFileExists,\leq,\let,\mathpalette}
% \DoNotIndex{\NeedsTeXFormat,\ldots,\ldotp,\newcommand,\newcounter,\or}
% \DoNotIndex{\PackageInfo,\PackageWarning,\parm,\ProcessOptions,\protected@edef}
% \DoNotIndex{\providecommand,\ProvidesPackage,\relax,\renewcommand,\RequirePackage}
% \DoNotIndex{\setcounter,\setkeys,\rlap,\setminus,\widthof,\mathrm}
%
%\section{Usage}
%
% This package is maybe not very suitable for the end user. It redefines
% |\newtheorem| in a way that lets other packages (or the user) add code
% to the newly-defined theorems, in a reasonably cross-compatible (with 
% the kernel, \pkg{theorem} and \pkg{amsthm}) way.
%
% \textbf{Warning:} the new |\newtheorem| is a superset of the allowed 
% syntax. For example, you can give a star and both optional arguments, 
% even though you cannot have an unnumbered theorem that shares a counter
% and yet has a different reset-regimen. At some point, your command is
% re-assembled and passed on to the original |\newtheorem|. This might
% complain, or give you the usual ``Missing |\begin{document}|'' that
% marks too many arguments in the preamble.
%
% \DescribeMacro{\addtotheorem(pre/post)(head/foot)hook}
% A call to |\addtotheorempreheadhook|\oarg{kind}\marg{code} will
% insert the code to be executed whenever a kind theorem is opened, before
% the actual call takes place. (I.e., before the header ``Kind 1.3 (Foo)''
% is typeset.) There are also posthooks that are executed after this header,
% and the same for the end of the environment, even though nothing
% interesting ever happens there. These are useful to put
% |\begin{shaded}|\dots |\end{shaded}| around your theorems.
% Note that foothooks are executed LIFO (last addition first) and headhooks
% are executed FIFO (first addition first). There is a special kind called
% generic that is called for all theorems. This is the default if no kind
% is given.
%
% The added code may examine |\thmt@thmname| to get the title,
% |\thmt@envname| to get the environment's name, and |\thmt@optarg| to get
% the extra optional title, if any.
%
%\StopEventually{}
%\section{Implementation}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{thm-patch}[2008/09/02 v0.1beta6b thm-patch (ulmi)]
\let\@xa=\expandafter
\let\@nx=\noexpand
\RequirePackage{parseargs}

\@ifundefined{c@thmt@dummyctr}{%
  \newcounter{thmt@dummyctr}%
}{}%
\gdef\theHthmt@dummyctr{dummy.\arabic{thmt@dummyctr}}%
\gdef\thethmt@dummyctr{}%

\newif\ifthmt@isstarred
\newif\ifthmt@hassibling
\newif\ifthmt@hasparent

\@ifundefined{beamer@version}{%
  \def\thmt@parsetheoremargs#1{%
    \parse{%
      {\parseOpt[]{\def\thmt@optarg{##1}}{\let\thmt@optarg\@empty}}%
      {%
        \csname thmt@#1@preheadhook\endcsname
        \thmt@generic@preheadhook
        \protected@edef\tmp@args{%
          \ifx\@empty\thmt@optarg\else [\thmt@optarg]\fi
        }%
        \csname thmt@original@#1\@xa\endcsname\tmp@args
        \csname thmt@#1@postheadhook\endcsname
        \thmt@generic@postheadhook
        \let\@parsecmd\@empty
      }%
    }%
  }%
}{%
  \newif\ifthmt@hasoverlay
  \def\thmt@parsetheoremargs#1{%
    \parse{%
      {\parseOpt<>{\thmt@hasoverlaytrue\def\thmt@overlay{##1}}{}}%
      {\parseOpt[]{\def\thmt@optarg{##1}}{\let\thmt@optarg\@empty}}%
      {\ifthmt@hasoverlay\expandafter\@gobble\else\expandafter\@firstofone\fi
          {\parseOpt<>{\thmt@hasoverlaytrue\def\thmt@overlay{##1}}{}}%
      }%
      {%
        \csname thmt@#1@preheadhook\endcsname
        \thmt@generic@preheadhook
        \protected@edef\tmp@args{%
          \ifthmt@hasoverlay <\thmt@overlay>\fi
          \ifx\@empty\thmt@optarg\else [\thmt@optarg]\fi
        }%
        \csname thmt@original@#1\@xa\endcsname\tmp@args
        \csname thmt@#1@postheadhook\endcsname
        \thmt@generic@postheadhook
        \let\@parsecmd\@empty
      }%
    }
  }%
}

\let\thmt@original@newtheorem\newtheorem
\let\thmt@theoremdefiner\thmt@original@newtheorem

\def\newtheorem{%
  \thmt@isstarredfalse
  \thmt@hassiblingfalse
  \thmt@hasparentfalse
  \parse{%
    {\parseFlag*{\thmt@isstarredtrue}{}}%
    {\parseMand{\def\thmt@envname{##1}}}%
    {\parseOpt[]{\thmt@hassiblingtrue\def\thmt@sibling{##1}}{}}%
    {\parseMand{\def\thmt@thmname{##1}}}%
    {\parseOpt[]{\thmt@hasparenttrue\def\thmt@parent{##1}}{}}%
    {\let\@parsecmd\thmt@newtheoremiv}%
  }%
}

\newcommand\thmt@newtheoremiv{%
  \thmt@newtheorem@predefinition
  % whee, now reassemble the whole shit.
  \protected@edef\thmt@args{%
    \@nx\thmt@theoremdefiner%
    \ifthmt@isstarred *\fi
    {\thmt@envname}%
    \ifthmt@hassibling [\thmt@sibling]\fi
    {\thmt@thmname}%
    \ifthmt@hasparent [\thmt@parent]\fi
  }
  \thmt@args
  \thmt@newtheorem@postdefinition
}

\newcommand\thmt@newtheorem@predefinition{}
\newcommand\thmt@newtheorem@postdefinition{}

\g@addto@macro\thmt@newtheorem@postdefinition{%
  \@xa\thmt@addtheoremhook\@xa{\thmt@envname}%
  \ifthmt@isstarred\@namedef{the\thmt@envname}{}\fi
  \protected@edef\thmt@tmp{%
    \def\@nx\thmt@envname{\thmt@envname}%
    \def\@nx\thmt@thmname{\thmt@thmname}%
  }%
  \@xa\addtotheorempreheadhook\@xa[\@xa\thmt@envname\@xa]\@xa{%
    \thmt@tmp
  }%
}
\newcommand\thmt@addtheoremhook[1]{%
  % this adds two command calls to the newly-defined theorem.
  \@xa\let\csname thmt@original@#1\@xa\endcsname
          \csname#1\endcsname
  \@xa\renewcommand\csname #1\endcsname{%
    \thmt@parsetheoremargs{#1}%
  }%
  \@xa\let\csname thmt@original@end#1\@xa\endcsname\csname end#1\endcsname
  \@xa\def\csname end#1\endcsname{%
    % these need to be in opposite order of headhooks.
    \csname thmtgeneric@prefoothook\endcsname
    \csname thmt@#1@prefoothook\endcsname    
    \csname thmt@original@end#1\endcsname
    \csname thmt@generic@postfoothook\endcsname
    \csname thmt@#1@postfoothook\endcsname
  }%
  \@namedef{thmt@#1@preheadhook}{}%
  \@namedef{thmt@#1@postheadhook}{}%
  \@namedef{thmt@#1@prefoothook}{}%
  \@namedef{thmt@#1@postfoothook}{}%
}
\newcommand\thmt@generic@preheadhook{\refstepcounter{thmt@dummyctr}}
\newcommand\thmt@generic@postheadhook{}

\providecommand\g@prependto@macro[2]{%
  \begingroup
    \toks@\@xa{\@xa{#1}{#2}}%
    \def\tmp@a##1##2{##2##1}%
    \@xa\@xa\@xa\gdef\@xa\@xa\@xa#1\@xa\@xa\@xa{\@xa\tmp@a\the\toks@}%
  \endgroup
}

\newcommand\addtotheorempreheadhook[1][generic]{%
  \expandafter\g@addto@macro\csname thmt@#1@preheadhook\endcsname%
}
\newcommand\addtotheorempostheadhook[1][generic]{%
  \expandafter\g@addto@macro\csname thmt@#1@postheadhook\endcsname%
}

\newcommand\addtotheoremprefoothook[1][generic]{%
  \expandafter\g@prependto@macro\csname thmt@#1@prefoothook\endcsname%
}
\newcommand\addtotheorempostfoothook[1][generic]{%
  \expandafter\g@prependto@macro\csname thmt@#1@postfoothook\endcsname%
}

%    \end{macrocode}
% Since rev1.16, we add hooks to the proof environment as well, if it exists.
% If it doesn't exist at this point, we're probably using ntheorem as
% backend, where it goes through the regular theorem mechanism anyway.
%    \begin{macrocode}
\ifx\proof\endproof\else% yup, that's a quaint way of doing it :)
  % FIXME: this assumes proof has the syntax of theorems, which 
  % usually happens to be true (optarg overrides "Proof" string).
  % FIXME: refactor into thmt@addtheoremhook, but we really don't want to
  % call the generic-hook...
  \let\thmt@original@proof=\proof
  \renewcommand\proof{%
    \thmt@parseproofargs%
  }%
  \def\thmt@parseproofargs{%
    \parse{%
      {\parseOpt[]{\def\thmt@optarg{##1}}{\let\thmt@optarg\@empty}}%
      {%
        \thmt@proof@preheadhook
        %\thmt@generic@preheadhook
        \protected@edef\tmp@args{%
          \ifx\@empty\thmt@optarg\else [\thmt@optarg]\fi
        }%
        \csname thmt@original@proof\@xa\endcsname\tmp@args
        \thmt@proof@postheadhook
        %\thmt@generic@postheadhook
        \let\@parsecmd\@empty
      }%
    }%
  }%
  
  \let\thmt@original@endproof=\endproof
  \def\endproof{%
    % these need to be in opposite order of headhooks.
    %\csname thmtgeneric@prefoothook\endcsname
    \thmt@proof@prefoothook
    \thmt@original@endproof
    %\csname thmt@generic@postfoothook\endcsname
    \thmt@proof@postfoothook
  }%
  \@namedef{thmt@proof@preheadhook}{}%
  \@namedef{thmt@proof@postheadhook}{}%
  \@namedef{thmt@proof@prefoothook}{}%
  \@namedef{thmt@proof@postfoothook}{}%
\fi
%    \end{macrocode}
%\iffalse
%</patch>
%\fi
