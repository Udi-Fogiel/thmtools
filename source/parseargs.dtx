% \iffalse meta-comment
%
% Copyright (C) 2008 by Ulrich M. Schwarz
%
% This file may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3a.
% The license can be obtained from
% http://www.latex-project.org/lppl/lppl-1-3a.txt
%
% \fi
%
%\iffalse (hide this from DocInput)
%<*driver>
\documentclass{ltxdoc}

\usepackage[T1]{fontenc}
\usepackage{fourier}
\usepackage[scaled=0.8]{helvet}
\usepackage{luximono}

\usepackage{amsmath, amsthm}
\usepackage{parseargs}
\newtheorem{lemma}{Lemma}
\providecommand\pkg{\textsf}
\GetFileInfo{parseargs.sty}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \newcommand\ParseArgs{\textsf{ParseArgs}}
  \title{The \ParseArgs\ package\thanks{%
    This file documents version~\fileversion\ of~\filedate,
    RCS ${}$Id: parseargs.dtx,v 1.2 2008/06/22 12:09:33 ulmi Exp ulmi ${}$.
  }}
  \author{Ulrich M. Schwarz\thanks{ulmi@absatzen.de}}

  \maketitle

 \begin{abstract}
 A command like |\newtheorem| with its gazillion different argument
 possibilities is difficult to parse manually. And then, you add beamer
 support and you have to wade through a maze of twisty call indirections, 
 all alike.

 This package provides a generic argument parser similar to the one that
 will be in \LaTeX3.
 \end{abstract}

  \DocInput{thm-autoref.dtx}
\end{document}
%</driver>
%<*parseargs>
%\fi
%
% \CharacterTable
% {Upper-case \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
% Lower-case \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
% Digits \0\1\2\3\4\5\6\7\8\9
% Exclamation \! Double quote \" Hash (number) \#
% Dollar \$ Percent \% Ampersand \&
% Acute accent \' Left paren \( Right paren \)
% Asterisk \* Plus \+ Comma \,
% Minus \- Point \. Solidus \/
% Colon \: Semicolon \; Less than \<
% Equals \= Greater than \> Question mark \?
% Commercial at \@ Left bracket \[ Backslash \\
% Right bracket \] Circumflex \^ Underscore \_
% Grave accent \` Left brace \{ Vertical bar \|
% Right brace \} Tilde \~}
% \CheckSum{160}
%
% \DoNotIndex{\@for,\addtocounter,\arabic,\csname,\endcsname,\cup,\CurrentOption}
% \DoNotIndex{\{,\},\do,\define@key,\def,\DeclareOption,\else,\ensuremath,\expandafter}
% \DoNotIndex{\hspace,\fi,\rule,\ifcase,\ifx,\in,\InputIfFileExists,\leq,\let,\mathpalette}
% \DoNotIndex{\NeedsTeXFormat,\ldots,\ldotp,\newcommand,\newcounter,\or}
% \DoNotIndex{\PackageInfo,\PackageWarning,\parm,\ProcessOptions,\protected@edef}
% \DoNotIndex{\providecommand,\ProvidesPackage,\relax,\renewcommand,\RequirePackage}
% \DoNotIndex{\setcounter,\setkeys,\rlap,\setminus,\widthof,\mathrm}
%
%\section{Usage}
%
% The main command provided by the package is |\parse|\marg{spec}.
% \emph{spec} consists of groups of commands. Each group should set up the
% command |\@parsecmd| which is then run. The important point is that
% |\@parsecmd| will pick up its arguments from the running text, not from
% the rest of \emph{spec}. When it's done storing the arguments,
% |\@parsecmd| must call |\@parse| to continue with the next element of
% \emph{spec}. The process terminates when we run out of spec.
%
% Helper macros are provided for the three usual argument types: mandatory,
% optional, and flag.
%
%\StopEventually{}
%\section{Implementation}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{parseargs}[2008/05/12 v0.1alpha1 generic argument parser (ulmi)]

\newtoks\@parsespec
\def\parse@endquark{\parse@endquark}
\newcommand\parse[1]{%
  \@parsespec{#1\parse@endquark}\@parse}

\newcommand\@parse{%
  \edef\p@tmp{\the\@parsespec}%
  \ifx\p@tmp\parse@endquark
    \expandafter\@gobble
  \else
%    \typeout{parsespec remaining: \the\@parsespec}%
    \expandafter\@firstofone
  \fi{%
    \@parsepop
  }%
}
\def\@parsepop{%
  \expandafter\p@rsepop\the\@parsespec\@nil
  \@parsecmd
}
\def\p@rsepop#1#2\@nil{%
  #1%
  \@parsespec{#2}%
}

\newcommand\parseOpt[4]{%
  %\parseOpt{openchar}{closechar}{yes}{no}
%  \typeout{attemping #1#2...}%
  \def\@parsecmd{%
    \@ifnextchar#1{\@@reallyparse}{#4\@parse}
  }%
  \def\@@reallyparse#1##1#2{%
    #3\@parse
  }%
}

\newcommand\parseMand[1]{%
  %\parseMand{code}
  \def\@parsecmd##1{#1\@parse}%
}

\newcommand\parseFlag[3]{%
  %\parseFlag{flagchar}{yes}{no}
  \def\@parsecmd{%
    \@ifnextchar#1{#2\expandafter\@parse\@gobble}{#3\@parse}%
  }%
}
%    \end{macrocode}
%\iffalse
%</parseargs>
%\fi
